আমাদেরকে কন্ডিশনে বলে দিছে - a[i]*a[j]==i+j
তার মানে (i+j) সবসময় a[i] এবং a[j] এই ২ টা ভ্যালু দ্বারা অবশ্যই নিঃশেষে বিভাজ্য হবে।

1 2 3 4 5 6 7  -- index
	4	-value

ধরি , আমাদের  5 number index এ ভ্যালু আছে 4 । তাহলে এখন আমাদের চেক করতে হবে ৫ এর সাথে এর আগের (কারন i<j) কোন ইনডেক্স যোগ করলে সেই যোগফল 4 দ্বারা নিঃশেষে বিভাজ্য হচ্ছে । সেই ইনডেক্স গুলোকে এখন আমরা বের করব । বের করার নিয়ম হচ্ছে - 
(i) প্রথমে j এবং তার আগের ইনডেক্স যোগ করব । (j+j-1)
(ii) j তম ইনডেক্সের ভ্যালু দ্বারা এই যোগফলকে ভাগ করে ভাগশেষ নিব এবং ভাগশেষের সাথে ১ যোগ করব । x=(j+j-1)%a[j]
(5+4)%4
x=1 
x+=1
x=2

(iii) এখন j থেকে x তম ইনডেক্স বাদ দিলে যে ইনডেক্স পাওয়া যায় , j এবং সেই ইনডেক্স যোগ করলে যোগফল 4 দ্বারা , মানে j তম ইনডেক্সের ভ্যালু দ্বারা নিঃশেষে বিভাজ্য হবে । 

j-x 
5-2=3
5+3=8
8%4==0

অর্থাৎ 5 number index এর আগে 3 নাম্বার ইনডেক্স ই হল প্রথম ইনডেক্স যেটার সাথে ৫ যোগ করলে a[j] দ্বারা নিঃশেষে বিভাজ্য হয় । তবে আমাদের ৩ এর আগের ইনডেক্স গুলোও বের করতে হবে যেগুলোর সাথে j যোগ করলে যেগফল a[j] দ্বারা নিঃশেষে বিভাজ্য হবে । সেজন্য আমরা -

(iv) j-x থেকে a[j] বিয়োগ করে করে সামনে আগাতে থাকব , যতক্ষন না পর্যন্ত বিয়োগফল 1 এর চেয়ে ছোট হয়ে যাচ্ছে । বিয়োগ করে করে যে ভ্যালু গুলো পাব ,সেই ইনডেক্স এর সাথে j যোগ করলে যোগফল a[j] দ্বারা নিঃশেষে বিভাজ্য হবে । 

(v) নতুন ইনডেক্স গুলো হল i তম ইনডেক্স ।
(vi) প্রতিবার চেক করব a[i]*a[j]==i+j এই কন্ডিশন স্যটিসফাই করে নাকি । করলে একটা Pleasant pair পাওয়া গেল ।


for _ in range(int(input())):
    n=int(input())
    lst=[0]
    lst1=[int(x) for x in input().split()]
    lst.extend(lst1)
    sum=0
    for j in range(1,n+1):
        x=(j+j-1)%lst[j]
        x+=1
        i=j-x
        while(i>0):
            if lst[j]*lst[i]==i+j:
                sum+=1
            i-=lst[j]
    print(sum)




# Another solution and this one from CodeNCode . This is easy one .

for _ in range(int(input())):
    n=int(input());d=[]
    lst=[int(x) for x in input().split()]
    for i in range(n):
        d.append((lst[i],i+1))
    d.sort();cnt=0
# প্রত্যেকটা ভ্যালু আর তার ইনডেক্স কে একটা পেয়ার করে সর্ট করে নিলাম । 
    for i in range(n-1):
        for j in range(i+1,n):
            R=d[i][0]*d[j][0]
            L=d[i][1]+d[j][1]
            if R >2*n:
                break
# i এর মান সর্বোচ্চ যেতে পারবে n-1 পর্যন্ত আর j যেতে পারবে n পর্যন্ত । তাহলে i+j সর্বোচ্চ হতে পারবে 2n-1 . তাহলে ২ টা সংখ্যার গুনফল (R) > 2n হলে আর তো চেক করার দরকার নাই । লুপ থেকে বের
# হয়ে গেলাম । কারন ভ্যালু গুলো সর্ট করা আছে । এবং এই কন্ডিশন টার জন্যেই টিএলই খাবে না । 
            elif R==L:
                cnt+=1
    print(cnt)
